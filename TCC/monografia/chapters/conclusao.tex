Neste capítulo iremos apresentar as conclusões obtidas com os resultados dos experimentos realizados, além de uma breve explanação sobre quais são os rumos que podem ser tomados a fim de evoluir o sistema, quais melhorias podem ser realizadas de modo a garantir um programa mais robusto e confiável.
\\

\section{Conclusões}
%Após a construção do sistema e a análise realizada sobre os dados coletados em nossos experimentos foi possível levantar algumas conclusões sobre o nosso sistema de arquivos distribuídos baseado nos conceitos de RAID.


Neste trabalho conseguimos construir um sistema de arquivos distribuídos tolerante a falha, cujo o sistema consegue assegurar a confiabilidade dos arquivos armazenados usando os conceitos de RAID e o serviço fornecido pelo sistema é protegido através de uso da biblioteca \textit{BFT-SMaRt}.
Os resultados obtidos no experimento mostram que o RAID 5, que usa abordagem de geração paridade, tem melhor eficiência para transferência de dados comparado ao RAID 1, que usa a replicação de arquivo, perdendo apenas para RAID 0, que focaliza em ter maior desempenho sem preocupar na segurança dos arquivos.
Assim, conseguimos mostrar as vantagens de adotar os concentos de RAID na construção do sistema de arquivos distribuídos, na parte de conjunto de armazenamento de dados. Acreditamos que o RAID 5 seria uma opção adequada para casos que necessitam satisfazer condições de desempenho razoável para operações dos arquivos, possibilitando manter a segurança dos dados armazenados com custo de espaço relativamente menor.
\\


\section{Trabalhos Futuros}

Neste trabalho foi realizado os experimentos com objetivo de fazer a comparação de desempenho para armazenamento de arquivos entre três tipos de RAID, dando mais ênfase em operação de leitura e escrita de dados.
Mas ainda podem ser feitos outros tipos de experimentos para fazer as comparações, como verificar o que acontece com relação ao desempenho dos tipos de RAID quando aumenta o número de servidores em operação ou comparar a eficiência de recuperação de um arquivo entre RAID 1 e RAID 5. Também pode-se estender o sistema para suportar outros tipos de RAID, além de testá-los em casos de falhas.
\\

Atualmente todo o gerenciamento realizado pelo serviço de metadados ocorre em tempo de execução, sendo salvo apenas em memória, pretendemos modificar o código para que o mesmo possibilite que as informações gerencias sejam armazenadas em disco, memória não volátil. Pois da forma realizada atualmente, toda vez que o sistema é iniciado as informações gerencias estão em branco, ou seja, todos os blocos de arquivos armazenados no serviço de armazenamento não passam de lixo, espaço de disco desperdiçado. Quando o serviço de metadados estiver integrado com algum tipo de banco de dados esses dados serão preservados mesmo quando os servidores precisarem ser desligados por qualquer motivo.
\\

Visto os resultados obtidos em nossos experimentos, observamos que o sistema comporta, sem diminuir drasticamente o tempo de resposta, cinquenta usuários simultâneos  solicitando diversas operações, pretendemos estudar modos para aumentar essa quantidade, de modo que o nosso sistema possa ser usado em um ambiente real.
Além disso, na realização de experimentos foi observada a ocorrência de algumas exceções durante a execução do programa nas máquinas remotas de servidores de armazenamento. As exceções foram de \textit{OutOfMemoryError: Java heap space}, causado pela possível falta de memória disponível no JVM, a máquina virtual de java, e de \textit{OutOfMemoryError: GC Overhead limit exceeded}, a exceção que ocorre quando o coletor de lixo de java consome a maioria de tempo de execução desalocando componentes desnecessários da memória, impedindo que o programa prossegue a sua tarefa.
Durante experimento elas foram evitadas mudando a configuração básica do JVM, aumentando a capacidade máxima da memória que pode utilizar. Contudo, como não podemos considerar que todos os computadores são equipados com memória suficiente para executar o nosso sistema, é necessário que seja feito a redução de uso da memória por sistema. 
Como neste trabalho foi focalizado principalmente em construção do sistema, o código fonte do programa ainda pode ser revisado e otimizado, assim, conseguindo o melhoramento em relação ao uso da memória e, se for possível, o aumento no desempenho do sistema todo.
\\


